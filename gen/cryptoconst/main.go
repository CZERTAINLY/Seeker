// gen generates various tls constants to be used in a program
package main

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s input.csv output.go\n", os.Args[0])
		os.Exit(1)
	}

	inFile := os.Args[1]
	outFile := os.Args[2]
	tstFile := strings.Replace(outFile, ".go", "_test.go", 1)
	_, pkg := filepath.Split(outFile)
	pkg = strings.Replace(pkg, ".go", "", 1)

	in, err := os.Open(inFile)
	if err != nil {
		log.Fatalf("cannot open input: %v", err)
	}
	defer func() {
		err = in.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()

	tlsEntries, err := parseTLSConstants(in)
	if err != nil {
		log.Fatalf("cannot parse csv %s: %v", inFile, err)
	}

	parsed := make(map[string]CipherSuite, len(tlsEntries))
	for _, e := range tlsEntries {
		suite, err := ParseCipherSuite(e.desc)
		if err != nil {
			log.Printf("E: parsing %q fail: %s", e.desc, err)
		}
		parsed[e.desc] = suite
	}
	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("", "  ")
	err = enc.Encode(parsed)
	if err != nil {
		log.Fatal(err)
	}

	// go source code
	buf := newErrFmt()
	genHeader(buf, pkg, inFile)
	genTLSConstants(buf, tlsEntries)
	genFunctions(buf)

	if buf.Err() != nil {
		log.Fatalf("cannot code: %s", err)
	}

	// go test code
	tbuf := newErrFmt()
	genHeader(tbuf, pkg, inFile)
	genImports(tbuf, "testing")
	genTLSTest(tbuf, tlsEntries)

	if tbuf.Err() != nil {
		log.Fatalf("cannot tests: %s", err)
	}

	// Format
	var src, tsrc []byte
	if false {
		src, err = format.Source(buf.Bytes())
		if err != nil {
			log.Fatalf("gofmt failed: %v\nRaw:\n%s", err, buf.String())
		}

		tsrc, err = format.Source(tbuf.Bytes())
		if err != nil {
			log.Fatalf("gofmt failed: %v\nRaw:\n%s", err, tbuf.String())
		}
	} else {
		src, tsrc = buf.Bytes(), tbuf.Bytes()
	}

	if err := os.WriteFile(outFile, src, 0644); err != nil {
		log.Fatalf("cannot write output: %s", err)
	}
	if err := os.WriteFile(tstFile, tsrc, 0644); err != nil {
		log.Fatalf("cannot write test: %s", err)
	}
}

// errFmt provides fmt.Printf like methods, but handles the errors internally
// simplify error handling for code doing a lot of Printfs
type errFmt struct {
	w   *bytes.Buffer
	err error
}

func newErrFmt() *errFmt {
	buf := make([]byte, 0, 1024*1024)
	return &errFmt{w: bytes.NewBuffer(buf[:])}
}

func (b *errFmt) Println(a ...any) {
	if b.err != nil {
		return
	}
	_, err := fmt.Fprintln(b.w, a...)
	b.err = err
}

func (b *errFmt) Printf(format string, a ...any) {
	if b.err != nil {
		return
	}
	_, err := fmt.Fprintf(b.w, format, a...)
	b.err = err
}

func (b *errFmt) Bytes() []byte {
	return b.w.Bytes()
}

func (b *errFmt) String() string {
	return b.w.String()
}

func (b *errFmt) Err() error {
	return b.err
}

type tlsEntry struct {
	desc  string
	ident string
	value [2]int
	code  uint16
}

func parseTLSConstants(in io.Reader) ([]tlsEntry, error) {
	r := csv.NewReader(in)
	r.FieldsPerRecord = -1 // allow variable length

	records, err := r.ReadAll()
	if err != nil {
		return nil, fmt.Errorf("cannot read csv: %w", err)
	}
	if len(records) < 2 {
		return nil, fmt.Errorf("csv is empty")
	}

	// skip header
	records = records[1:]

	tlsEntries := make([]tlsEntry, 0, len(records))
	for _, rec := range records {
		if len(rec) < 2 {
			continue
		}
		value := strings.Trim(rec[0], `"`)
		desc := strings.Trim(rec[1], `"`)
		ident := sanitize(desc)
		if value == "" || ident == "" {
			continue
		}

		// Parse "0x00,0x01" -> 0x00,0x01 integers
		parts := strings.Split(value, ",")
		if len(parts) != 2 {
			continue
		}
		var b1, b2 int
		_, err = fmt.Sscanf(parts[0], "0x%X", &b1)
		if err != nil {
			return nil, err
		}
		_, err = fmt.Sscanf(parts[1], "0x%X", &b2)
		if err != nil {
			return nil, err
		}

		e := tlsEntry{
			desc:  desc,
			ident: ident,
			value: [2]int{b1, b2},
			code:  uint16((b1 << 8) | b2),
		}
		tlsEntries = append(tlsEntries, e)

	}

	return tlsEntries, nil
}

func genHeader(out *errFmt, pkg string, inFile string) {
	out.Println("// Code generated by gen_ciphers.go; DO NOT EDIT.")
	out.Println("// https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml")
	out.Println("// https://github.com/openssl/openssl/blob/d0899abb1b7654922b2272070d8fb593d8b13cff/crypto/objects/objects.txt")
	out.Printf("// file: %s, date: %s\n", inFile, time.Now().UTC().Format(time.RFC3339))
	out.Printf(`
package %s
`, pkg)
}

func genImports(out *errFmt, pkgs ...string) {
	out.Println("import (")
	for _, pkg := range pkgs {
		out.Printf("\t%q\n", pkg)
	}
	out.Println(")")
}

func genTLSConstants(out *errFmt, tlsEntries []tlsEntry) {
	out.Printf(`
type CipherSuite uint16
type OIDValue string
`)

	// generate tls names constants
	out.Println("const (")
	for _, e := range tlsEntries {
		out.Printf("\t%s CipherSuite = 0x%04X\n", e.ident, e.code)
	}
	out.Printf(")\n\n")

	// generate map string to CipherSuite code
	out.Println("var toCipherSuite = map[string]CipherSuite{")
	for _, e := range tlsEntries {
		out.Printf("\t%q: %s,\n", e.desc, e.ident)
	}
	out.Printf("}\n")
}

func genFunctions(out *errFmt) {
	out.Printf(`
// Code returns IANA code for given cipher
func Code(name string) (CipherSuite, bool) {
	code, ok := toCipherSuite[name]
	return code, ok
}
		`)
}

func genTLSTest(out *errFmt, tlsEntries []tlsEntry) {
	// generate tests
	out.Printf(`
func TestCipherSuite(t *testing.T) {
	var tests = []struct{
		desc string
		code CipherSuite
	} {
`)

	for _, e := range tlsEntries {
		out.Printf("\t\t{\"%s\", 0x%04X},\n", e.desc, e.code)
	}

	out.Printf(`
	}
	for _, tc := range tests {
		got, ok := Code(tc.desc)
		if !ok {
			t.Fatalf("code %%s not found", tc.desc)
		}
		if got != tc.code {
			t.Fatalf("code %%s: got 0x%%04X, want 0x%%04X", tc.desc, got, tc.code)
		}
	}
}
`)
}

// sanitize makes a valid Go identifier from a cipher suite name
func sanitize(s string) string {
	if strings.Contains(s, "Reserved") ||
		strings.Contains(s, "Unassigned") {
		return ""
	}
	// Keep letters, numbers, underscores
	s = strings.ReplaceAll(s, "\n", "")
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, " ", "_")
	return s
}
