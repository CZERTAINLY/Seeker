// gen generates various tls constants to be used in a program
package main

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strings"
	"time"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s input.csv output.go\n", os.Args[0])
		os.Exit(1)
	}

	inFile := os.Args[1]
	outFile := os.Args[2]
	tstFile := strings.Replace(outFile, ".go", "_test.go", 1)

	in, err := os.Open(inFile)
	if err != nil {
		log.Fatalf("cannot open input: %v", err)
	}
	defer func() {
		err = in.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()

	buf := newErrFmt()
	tbuf := newErrFmt()
	if err := gen(buf, tbuf, in, inFile); err != nil {
		log.Fatalf("cannot generate: %v", err)
	}

	// Format
	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("gofmt failed: %v\nRaw:\n%s", err, buf.String())
	}

	tsrc, err := format.Source(tbuf.Bytes())
	if err != nil {
		log.Fatalf("gofmt failed: %v\nRaw:\n%s", err, tbuf.String())
	}

	if err := os.WriteFile(outFile, src, 0644); err != nil {
		log.Fatalf("cannot write output: %v", err)
	}
	if err := os.WriteFile(tstFile, tsrc, 0644); err != nil {
		log.Fatalf("cannot write test: %v", err)
	}
}

type errFmt struct {
	w   *bytes.Buffer
	err error
}

func newErrFmt() *errFmt {
	buf := make([]byte, 0, 1024*1024)
	return &errFmt{w: bytes.NewBuffer(buf[:])}
}

func (b *errFmt) Println(a ...any) {
	if b.err != nil {
		return
	}
	_, err := fmt.Fprintln(b.w, a...)
	b.err = err
}

func (b *errFmt) Printf(format string, a ...any) {
	if b.err != nil {
		return
	}
	_, err := fmt.Fprintf(b.w, format, a...)
	b.err = err
}

func (b *errFmt) Bytes() []byte {
	return b.w.Bytes()
}

func (b *errFmt) String() string {
	return b.w.String()
}

func (b *errFmt) Err() error {
	return b.err
}

func gen(out *errFmt, tout *errFmt, in io.Reader, inFile string) error {
	r := csv.NewReader(in)
	r.FieldsPerRecord = -1 // allow variable length

	records, err := r.ReadAll()
	if err != nil {
		log.Fatalf("cannot read csv: %v", err)
	}
	if len(records) < 2 {
		log.Fatalf("csv is empty")
	}

	// skip header
	records = records[1:]

	out.Println("// Code generated by gen_ciphers.go; DO NOT EDIT.")
	out.Println("// https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml")
	out.Println("// https://github.com/zmap/zcrypto/blob/dcac38cad4c0/x509/pkix/oid_names.go")
	out.Printf("// file: %s, date: %s\n", inFile, time.Now().UTC().Format(time.RFC3339))
	out.Printf(`
package certconst

type CipherSuite uint16
type OIDValue string

`)

	type tlsEntry struct {
		desc  string
		ident string
		value [2]int
		code  uint16
	}

	tlsEntries := make([]tlsEntry, 0, len(records))
	for _, rec := range records {
		if len(rec) < 2 {
			continue
		}
		value := strings.Trim(rec[0], `"`)
		desc := strings.Trim(rec[1], `"`)
		ident := sanitize(desc)
		if value == "" || ident == "" {
			continue
		}

		// Parse "0x00,0x01" -> 0x00,0x01 integers
		parts := strings.Split(value, ",")
		if len(parts) != 2 {
			continue
		}
		var b1, b2 int
		_, err = fmt.Sscanf(parts[0], "0x%X", &b1)
		if err != nil {
			return err
		}
		_, err = fmt.Sscanf(parts[1], "0x%X", &b2)
		if err != nil {
			return err
		}

		e := tlsEntry{
			desc:  desc,
			ident: ident,
			value: [2]int{b1, b2},
			code:  uint16((b1 << 8) | b2),
		}
		tlsEntries = append(tlsEntries, e)

	}

	// generate tls names constants
	out.Println("const (")
	for _, e := range tlsEntries {
		out.Printf("\t%s CipherSuite = 0x%04X\n", e.ident, e.code)
	}
	out.Printf(")\n\n")

	// generate map string to CipherSuite code
	out.Println("var toCipherSuite = map[string]CipherSuite{")
	for _, e := range tlsEntries {
		out.Printf("\t%q: %s,\n", e.desc, e.ident)
	}
	out.Printf("}\n")

	out.Printf(`
// Code returns IANA code for given cipher
func Code(name string) (CipherSuite, bool) {
	code, ok := toCipherSuite[name]
	return code, ok
}
		`)

	// generate tests
	tout.Printf(`
package certconst

import (
	"testing"
)

func TestCipherSuite(t *testing.T) {
	var tests = []struct{
		desc string
		code CipherSuite
	} {
`)

	for _, e := range tlsEntries {
		tout.Printf("\t\t{\"%s\", 0x%04X},\n", e.desc, e.code)
	}

	tout.Printf(`
	}
	for _, tc := range tests {
		got, ok := Code(tc.desc)
		if !ok {
			t.Fatalf("code %%s not found", tc.desc)
		}
		if got != tc.code {
			t.Fatalf("code %%s: got 0x%%04X, want 0x%%04X", tc.desc, got, tc.code)
		}
	}
}
`)

	if out.Err() != nil {
		return out.Err()
	} else if tout.Err() != nil {
		return tout.Err()
	}

	return nil
}

// sanitize makes a valid Go identifier from a cipher suite name
func sanitize(s string) string {
	if strings.Contains(s, "Reserved") ||
		strings.Contains(s, "Unassigned") {
		return ""
	}
	// Keep letters, numbers, underscores
	s = strings.ReplaceAll(s, "\n", "")
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, " ", "_")
	return s
}
