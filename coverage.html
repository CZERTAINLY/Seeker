
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>x509: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/CZERTAINLY/Seeker/internal/x509/component.go (32.4%)</option>
				
				<option value="file1">github.com/CZERTAINLY/Seeker/internal/x509/der.go (100.0%)</option>
				
				<option value="file2">github.com/CZERTAINLY/Seeker/internal/x509/jks.go (89.5%)</option>
				
				<option value="file3">github.com/CZERTAINLY/Seeker/internal/x509/pem.go (78.3%)</option>
				
				<option value="file4">github.com/CZERTAINLY/Seeker/internal/x509/pkcs12.go (86.8%)</option>
				
				<option value="file5">github.com/CZERTAINLY/Seeker/internal/x509/pkcs7.go (76.2%)</option>
				
				<option value="file6">github.com/CZERTAINLY/Seeker/internal/x509/x509.go (85.2%)</option>
				
				<option value="file7">github.com/CZERTAINLY/Seeker/internal/x509/zip.go (84.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package x509

import (
        "crypto/dsa" //nolint:staticcheck // seeker is going to recognize even obsoleted crypto
        "crypto/ecdsa"
        "crypto/ed25519"
        "crypto/rsa"
        "crypto/x509"
        "encoding/base64"
        "fmt"
        "path/filepath"
        "time"

        "github.com/CZERTAINLY/Seeker/internal/cdxprops"
        cdx "github.com/CycloneDX/cyclonedx-go"
)

// toComponent converts an X.509 certificate to a CycloneDX component
func toComponent(cert *x509.Certificate, path string, source string) (cdx.Component, error) <span class="cov8" title="1">{
        subjectPublicKeyRef, err := readSubjectPublicKeyRef(cert)
        if err != nil </span><span class="cov0" title="0">{
                return cdx.Component{}, err
        }</span>

        <span class="cov8" title="1">absPath, _ := filepath.Abs(path)

        c := cdx.Component{
                Type:    cdx.ComponentTypeCryptographicAsset,
                Name:    cert.Subject.String(),
                Version: cert.SerialNumber.String(),
                CryptoProperties: &amp;cdx.CryptoProperties{
                        AssetType: cdx.CryptoAssetTypeCertificate,
                        CertificateProperties: &amp;cdx.CertificateProperties{
                                SubjectName:           cert.Subject.String(),
                                IssuerName:            cert.Issuer.String(),
                                NotValidBefore:        cert.NotBefore.Format(time.RFC3339),
                                NotValidAfter:         cert.NotAfter.Format(time.RFC3339),
                                SignatureAlgorithmRef: readSignatureAlgorithmRef(cert),
                                SubjectPublicKeyRef:   subjectPublicKeyRef,
                                CertificateFormat:     "X.509",
                                CertificateExtension:  filepath.Ext(path),
                        },
                },
        }

        cdxprops.SetComponentProp(&amp;c, cdxprops.CzertainlyComponentCertificateSourceFormat, source)
        cdxprops.SetComponentProp(&amp;c, cdxprops.CzertainlyComponentCertificateBase64Content, base64.StdEncoding.EncodeToString(cert.Raw))
        cdxprops.AddEvidenceLocation(&amp;c, absPath)

        return c, nil</span>
}

func readSignatureAlgorithmRef(cert *x509.Certificate) cdx.BOMReference <span class="cov8" title="1">{
        switch cert.SignatureAlgorithm </span>{
        case x509.MD5WithRSA:<span class="cov0" title="0">
                return "crypto/algorithm/md5-rsa@1.2.840.113549.1.1.4"</span>
        case x509.SHA1WithRSA:<span class="cov0" title="0">
                return "crypto/algorithm/sha-1-rsa@1.2.840.113549.1.1.5"</span>
        case x509.SHA256WithRSA:<span class="cov8" title="1">
                return "crypto/algorithm/sha-256-rsa@1.2.840.113549.1.1.11"</span>
        case x509.SHA384WithRSA:<span class="cov0" title="0">
                return "crypto/algorithm/sha-384-rsa@1.2.840.113549.1.1.12"</span>
        case x509.SHA512WithRSA:<span class="cov0" title="0">
                return "crypto/algorithm/sha-512-rsa@1.2.840.113549.1.1.13"</span>
        case x509.DSAWithSHA1:<span class="cov0" title="0">
                return "crypto/algorithm/sha-1-dsa@1.2.840.10040.4.3"</span>
        case x509.DSAWithSHA256:<span class="cov0" title="0">
                return "crypto/algorithm/sha-256-dsa@2.16.840.1.101.3.4.3.2"</span>
        case x509.ECDSAWithSHA1:<span class="cov0" title="0">
                return "crypto/algorithm/sha-1-ecdsa@1.2.840.10045.4.1"</span>
        case x509.ECDSAWithSHA256:<span class="cov0" title="0">
                return "crypto/algorithm/sha-256-ecdsa@1.2.840.10045.4.3.2"</span>
        case x509.ECDSAWithSHA384:<span class="cov0" title="0">
                return "crypto/algorithm/sha-384-ecdsa@1.2.840.10045.4.3.3"</span>
        case x509.ECDSAWithSHA512:<span class="cov0" title="0">
                return "crypto/algorithm/sha-512-ecdsa@1.2.840.10045.4.3.4"</span>
        case x509.SHA256WithRSAPSS:<span class="cov0" title="0">
                return "crypto/algorithm/sha-256-rsassa-pss@1.2.840.113549.1.1.10"</span>
        case x509.SHA384WithRSAPSS:<span class="cov0" title="0">
                return "crypto/algorithm/sha-384-rsassa-pss@1.2.840.113549.1.1.10"</span>
        case x509.SHA512WithRSAPSS:<span class="cov0" title="0">
                return "crypto/algorithm/sha-512-rsassa-pss@1.2.840.113549.1.1.10"</span>
        case x509.PureEd25519:<span class="cov0" title="0">
                return "crypto/algorithm/ed25519@1.3.101.112"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func readSubjectPublicKeyRef(cert *x509.Certificate) (cdx.BOMReference, error) <span class="cov8" title="1">{
        switch pub := cert.PublicKey.(type) </span>{
        case *rsa.PublicKey:<span class="cov8" title="1">
                return cdx.BOMReference(fmt.Sprintf("crypto/key/rsa-%d@1.2.840.113549.1.1.1", pub.N.BitLen())), nil</span>
        case *ecdsa.PublicKey:<span class="cov0" title="0">
                bitSize := pub.Params().BitSize
                // Curve OIDs
                switch bitSize </span>{
                case 256:<span class="cov0" title="0">
                        return "crypto/key/ecdsa-p256@1.2.840.10045.3.1.7", nil</span>
                case 384:<span class="cov0" title="0">
                        return "crypto/key/ecdsa-p384@1.3.132.0.34", nil</span>
                case 521:<span class="cov0" title="0">
                        return "crypto/key/ecdsa-p521@1.3.132.0.35", nil</span>
                default:<span class="cov0" title="0">
                        return "", fmt.Errorf("unsupported ECDSA key size: %d", bitSize)</span>
                }
        case ed25519.PublicKey:<span class="cov0" title="0">
                return "crypto/key/ed25519-256@1.3.101.112", nil</span>
        case *dsa.PublicKey:<span class="cov0" title="0">
                return cdx.BOMReference(fmt.Sprintf("crypto/key/dsa-%d@1.2.840.10040.4.1", pub.P.BitLen())), nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported public key type: %T", cert.PublicKey)</span>
        }
}</pre>
		
		<pre class="file" id="file1" style="display: none">package x509

import (
        "context"
        "crypto/x509"
        "log/slog"
)

// derDetector handles raw DER certificate detection
type derDetector struct{}

// detect finds certificates in raw DER format (single or concatenated)
func (d derDetector) detect(ctx context.Context, b []byte) []certHit <span class="cov8" title="1">{
        slog.DebugContext(ctx, "Detecting Raw DER: single/concatenated certs, or DER-encoded PKCS#7")
        
        var out []certHit
        
        // Try to parse as raw DER certificates first
        if cs, err := x509.ParseCertificates(b); err == nil </span><span class="cov8" title="1">{
                for _, c := range cs </span><span class="cov8" title="1">{
                        if c != nil </span><span class="cov8" title="1">{
                                out = append(out, certHit{Cert: c, Source: "DER"})
                        }</span>
                }
                <span class="cov8" title="1">return out</span>
        }
        
        // If that fails, check if it's DER PKCS#7
        <span class="cov8" title="1">if sniffPKCS7DER(b) </span><span class="cov8" title="1">{
                if cs := parsePKCS7Safe(ctx, b, false /*strict*/); len(cs) &gt; 0 </span><span class="cov8" title="1">{
                        for _, c := range cs </span><span class="cov8" title="1">{
                                if c != nil </span><span class="cov8" title="1">{
                                        out = append(out, certHit{Cert: c, Source: "PKCS7-DER"})
                                }</span>
                        }
                }
        }
        
        <span class="cov8" title="1">return out</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package x509

import (
        "bytes"
        "context"
        "crypto/x509"
        "encoding/binary"
        "log/slog"

        "github.com/pavlo-v-chernykh/keystore-go/v4"
)

// jksDetector handles JKS/JCEKS keystore detection
type jksDetector struct{}

// detect finds certificates in JKS/JCEKS keystores
func (d jksDetector) detect(ctx context.Context, b []byte) []certHit <span class="cov8" title="1">{
        slog.DebugContext(ctx, "Detecting JKS / JCEKS (Java keystores)")
        
        var out []certHit
        
        if certs, kind := jksAll(b); len(certs) &gt; 0 &amp;&amp; kind != "" </span><span class="cov8" title="1">{
                for _, c := range certs </span><span class="cov8" title="1">{
                        if c != nil </span><span class="cov8" title="1">{
                                out = append(out, certHit{Cert: c, Source: kind})
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return out</span>
}

// --- JKS/JCEKS support ---

const (
        jksMagic   uint32 = 0xFEEDFEED
        jceksMagic uint32 = 0xCECECECE
)

// sniffJKS returns (true, "JKS"|"JCEKS") if bytes look like a JKS/JCEKS keystore.
// It also validates the version (1 or 2) to reduce false positives.
func sniffJKS(b []byte) (bool, string) <span class="cov8" title="1">{
        if len(b) &lt; 8 </span><span class="cov0" title="0">{
                return false, ""
        }</span>
        <span class="cov8" title="1">magic := binary.BigEndian.Uint32(b[0:4])
        if magic != jksMagic &amp;&amp; magic != jceksMagic </span><span class="cov8" title="1">{
                return false, ""
        }</span>
        <span class="cov8" title="1">version := binary.BigEndian.Uint32(b[4:8])
        if version != 1 &amp;&amp; version != 2 </span><span class="cov0" title="0">{
                return false, ""
        }</span>
        <span class="cov8" title="1">if magic == jksMagic </span><span class="cov8" title="1">{
                return true, "JKS"
        }</span>
        <span class="cov0" title="0">return true, "JCEKS"</span>
}

var jksPasswords = []string{"changeit", ""} // typical defaults; adjust as needed

func jksAll(b []byte) ([]*x509.Certificate, string) <span class="cov8" title="1">{
        ok, kind := sniffJKS(b)
        if !ok </span><span class="cov8" title="1">{
                return nil, ""
        }</span>

        <span class="cov8" title="1">var out []*x509.Certificate
        for _, pw := range jksPasswords </span><span class="cov8" title="1">{
                ks := keystore.New()
                if err := ks.Load(bytes.NewReader(b), []byte(pw)); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">aliases := ks.Aliases()
                for _, alias := range aliases </span><span class="cov8" title="1">{
                        // 1) TrustedCertificateEntry
                        if tce, err := ks.GetTrustedCertificateEntry(alias); err == nil </span><span class="cov8" title="1">{
                                if c, err := x509.ParseCertificate(tce.Certificate.Content); err == nil </span><span class="cov8" title="1">{
                                        out = append(out, c)
                                }</span>
                        }
                        // 2) PrivateKeyEntry -&gt; includes certificate chain
                        <span class="cov8" title="1">if pke, err := ks.GetPrivateKeyEntry(alias, []byte(pw)); err == nil </span><span class="cov8" title="1">{
                                for _, kc := range pke.CertificateChain </span><span class="cov8" title="1">{
                                        if c, err := x509.ParseCertificate(kc.Content); err == nil </span><span class="cov8" title="1">{
                                                out = append(out, c)
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">if len(out) &gt; 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return out, kind</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package x509

import (
        "context"
        "crypto/x509"
        "encoding/pem"
        "log/slog"
)

// pemDetector handles PEM block detection for certificates, PKCS7, and PKCS12
type pemDetector struct{}

// detect finds all certificates in PEM blocks
func (d pemDetector) detect(ctx context.Context, b []byte) []certHit <span class="cov8" title="1">{
        slog.DebugContext(ctx, "Detecting ALL PEM blocks anywhere in the blob (handles leading text)")
        
        var out []certHit
        rest := b
        
        for </span><span class="cov8" title="1">{
                p, r := pem.Decode(rest)
                if p == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                
                <span class="cov8" title="1">switch p.Type </span>{
                case "CERTIFICATE", "TRUSTED CERTIFICATE":<span class="cov8" title="1">
                        if cs, err := x509.ParseCertificates(p.Bytes); err == nil </span><span class="cov8" title="1">{
                                for _, c := range cs </span><span class="cov8" title="1">{
                                        if c != nil </span><span class="cov8" title="1">{
                                                out = append(out, certHit{Cert: c, Source: "PEM"})
                                        }</span>
                                }
                        }
                case "PKCS7", "CMS":<span class="cov8" title="1">
                        if cs := parsePKCS7Safe(ctx, p.Bytes, true /*permissive for PEM*/); len(cs) &gt; 0 </span><span class="cov8" title="1">{
                                for _, c := range cs </span><span class="cov8" title="1">{
                                        if c != nil </span><span class="cov8" title="1">{
                                                out = append(out, certHit{Cert: c, Source: "PKCS7-PEM"})
                                        }</span>
                                }
                        }
                case "PKCS12":<span class="cov0" title="0">
                        // Only parse PKCS#12 if it actually sniffs as PFX (avoid mis-parsing JKS/BKS as PFX)
                        if sniffPKCS12(p.Bytes) </span><span class="cov0" title="0">{
                                certs := pkcs12All(p.Bytes)
                                for _, c := range certs </span><span class="cov0" title="0">{
                                        if c != nil </span><span class="cov0" title="0">{
                                                out = append(out, certHit{Cert: c, Source: "PKCS12"})
                                        }</span>
                                }
                        }
                default:<span class="cov8" title="1"></span>
                        // ignore keys, CSRs, CRLs, etc.
                }
                <span class="cov8" title="1">rest = r</span>
        }
        
        <span class="cov8" title="1">return out</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package x509

import (
        "context"
        "crypto/x509"
        "encoding/asn1"
        "log/slog"

        "software.sslmate.com/src/go-pkcs12"
)

// pkcs12Detector handles PKCS#12/PFX detection
type pkcs12Detector struct{}

// detect finds certificates in PKCS#12/PFX format
func (d pkcs12Detector) detect(ctx context.Context, b []byte) []certHit <span class="cov8" title="1">{
        slog.DebugContext(ctx, "Detecting PKCS#12 (PFX)")
        
        var out []certHit
        
        // Only try if it sniffs as PFX
        if sniffPKCS12(b) </span><span class="cov8" title="1">{
                certs := pkcs12All(b)
                for _, c := range certs </span><span class="cov8" title="1">{
                        if c != nil </span><span class="cov8" title="1">{
                                out = append(out, certHit{Cert: c, Source: "PKCS12"})
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return out</span>
}

// --- Strict PKCS#12 sniff ---
// Validates top-level PFX structure: SEQUENCE { version INTEGER, authSafe ContentInfo (...id-data or id-signedData...) , ... }
func sniffPKCS12(b []byte) bool <span class="cov8" title="1">{
        var top asn1.RawValue
        if _, err := asn1.Unmarshal(b, &amp;top); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if top.Class != asn1.ClassUniversal || top.Tag != asn1.TagSequence || !top.IsCompound </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">payload := top.Bytes
        // version INTEGER
        var ver int
        rest, err := asn1.Unmarshal(payload, &amp;ver)
        if err != nil || ver &lt; 0 || ver &gt; 10 </span><span class="cov8" title="1">{ // typical PFX version is 3
                return false
        }</span>
        // ContentInfo: SEQUENCE { contentType OID, [0] EXPLICIT ... OPTIONAL }
        <span class="cov8" title="1">type contentInfo struct {
                ContentType asn1.ObjectIdentifier
                Content     asn1.RawValue `asn1:"tag:0,explicit,optional"`
        }
        var ci contentInfo
        if _, err := asn1.Unmarshal(rest, &amp;ci); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // contentType must be id-data (1.2.840.113549.1.7.1) or id-signedData (1.2.840.113549.1.7.2)
        <span class="cov8" title="1">idData := asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 7, 1}
        idSignedData := asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 7, 2}
        return ci.ContentType.Equal(idData) || ci.ContentType.Equal(idSignedData)</span>
}

var pkcs12Passwords = []string{"changeit", "", "password"} // tweak as needed

// Robust PKCS#12: trust store first, then key+chain, then PEM fallback.
func pkcs12All(b []byte) []*x509.Certificate <span class="cov8" title="1">{
        var out []*x509.Certificate
        for _, pw := range pkcs12Passwords </span><span class="cov8" title="1">{
                // 1) Trust-store (certs only; e.g., Java truststore exports)
                if certs, err := pkcs12.DecodeTrustStore(b, pw); err == nil &amp;&amp; len(certs) &gt; 0 </span><span class="cov0" title="0">{
                        out = append(out, certs...)
                        return out
                }</span>
                // 2) Full chain (leaf + intermediates) if present
                <span class="cov8" title="1">if _, leaf, cas, err := pkcs12.DecodeChain(b, pw); err == nil </span><span class="cov8" title="1">{
                        if leaf != nil </span><span class="cov8" title="1">{
                                out = append(out, leaf)
                        }</span>
                        <span class="cov8" title="1">if len(cas) &gt; 0 </span><span class="cov0" title="0">{
                                out = append(out, cas...)
                        }</span>
                        <span class="cov8" title="1">if len(out) &gt; 0 </span><span class="cov8" title="1">{
                                return out
                        }</span>
                }
        }
        <span class="cov0" title="0">return out</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package x509

import (
        "bytes"
        "context"
        "crypto/x509"
        "encoding/asn1"
        "time"

        "github.com/smallstep/pkcs7"
)

// OID prefix: 1.2.840.113549.1.7 (PKCS#7/CMS ContentInfo contentType family)
var oidPkcs7Prefix = []int{1, 2, 840, 113549, 1, 7}

func oidHasPrefix(oid asn1.ObjectIdentifier, prefix []int) bool <span class="cov0" title="0">{
        if len(oid) &lt; len(prefix) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i := range prefix </span><span class="cov0" title="0">{
                if oid[i] != prefix[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Quick DER sniff: ContentInfo with contentType under 1.2.840.113549.1.7.*
// Be permissive: tolerate BER-ish lengths and fall back to a byte scan if needed.
func sniffPKCS7DER(b []byte) bool <span class="cov8" title="1">{
        if len(b) &lt; 4 </span><span class="cov0" title="0">{
                return false
        }</span>
        // Heuristic fast path: scan first 2KB for the OID bytes
        <span class="cov8" title="1">const maxScan = 2048
        prefixBytes := []byte{0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07}
        window := b
        if len(window) &gt; maxScan </span><span class="cov8" title="1">{
                window = window[:maxScan]
        }</span>
        <span class="cov8" title="1">if bytes.Contains(window, prefixBytes) </span><span class="cov8" title="1">{
                return true
        }</span>

        // Structured path
        <span class="cov8" title="1">var top asn1.RawValue
        if _, err := asn1.Unmarshal(b, &amp;top); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">type contentInfo struct {
                ContentType asn1.ObjectIdentifier
                Content     asn1.RawValue `asn1:"tag:0,explicit,optional"`
        }
        var ci contentInfo
        if _, err := asn1.Unmarshal(top.Bytes, &amp;ci); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">return oidHasPrefix(ci.ContentType, oidPkcs7Prefix)</span>
}

// Make the parser optionally "permissive" (e.g., for PEM blocks explicitly labeled PKCS7/CMS)
func parsePKCS7Safe(ctx context.Context, b []byte, permissive bool) []*x509.Certificate <span class="cov8" title="1">{
        // Only gate by sniff when not in permissive mode
        if !permissive &amp;&amp; !sniffPKCS7DER(b) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">type result struct{ certs []*x509.Certificate }
        ch := make(chan result, 1)

        timeoutCtx, cancel := context.WithTimeout(ctx, 2*time.Second)
        defer cancel()

        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{ _ = recover() }</span>()
                <span class="cov8" title="1">p7, err := pkcs7.Parse(b) // github.com/smallstep/pkcs7 (supports degenerate signedData)
                if err != nil || len(p7.Certificates) == 0 </span><span class="cov8" title="1">{
                        ch &lt;- result{nil}
                        return
                }</span>
                <span class="cov8" title="1">out := make([]*x509.Certificate, len(p7.Certificates))
                copy(out, p7.Certificates)
                ch &lt;- result{out}</span>
        }()

        <span class="cov8" title="1">select </span>{
        case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                return nil</span>
        case r := &lt;-ch:<span class="cov8" title="1">
                return r.certs</span>
        }
}</pre>
		
		<pre class="file" id="file6" style="display: none">package x509

import (
        "context"
        "crypto/sha256"
        "crypto/x509"
        "log/slog"

        "github.com/CZERTAINLY/Seeker/internal/model"

        cdx "github.com/CycloneDX/cyclonedx-go"
)

// ---- internal type to carry source/format label ----

type certHit struct {
        Cert   *x509.Certificate
        Source string // e.g., "PEM", "DER", "PKCS7-PEM", "PKCS7-DER", "PKCS12", "JKS", "JCEKS", "ZIP/&lt;subsource&gt;"
}

// Detector tries to parse the X509 certificate(s) and return a proper detection object
type Detector struct{}

func (d Detector) Detect(ctx context.Context, b []byte, path string) ([]model.Detection, error) <span class="cov8" title="1">{
        hits := findAllCerts(ctx, b)
        if len(hits) == 0 </span><span class="cov8" title="1">{
                return nil, model.ErrNoMatch
        }</span>

        <span class="cov8" title="1">components := make([]cdx.Component, 0, len(hits))
        for _, h := range hits </span><span class="cov8" title="1">{
                component, err := toComponent(h.Cert, path, h.Source)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">components = append(components, component)</span>
        }

        <span class="cov8" title="1">return []model.Detection{{
                Path:       path,
                Components: components,
        }}, nil</span>
}

func (d Detector) LogAttrs() []slog.Attr <span class="cov0" title="0">{
        return []slog.Attr{
                slog.String("detector", "x509"),
        }
}</span>

// -------- Certificate extraction (multi-source) --------

// detector interface for certificate detection
type detector interface {
        detect(ctx context.Context, b []byte) []certHit
}

func findAllCerts(ctx context.Context, b []byte) []certHit <span class="cov8" title="1">{
        seen := make(map[[32]byte]struct{})
        add := func(hits []certHit, out *[]certHit) </span><span class="cov8" title="1">{
                for _, h := range hits </span><span class="cov8" title="1">{
                        if h.Cert == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">fp := sha256.Sum256(h.Cert.Raw)
                        if _, dup := seen[fp]; dup </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">seen[fp] = struct{}{}
                        *out = append(*out, h)</span>
                }
        }

        <span class="cov8" title="1">out := make([]certHit, 0, 4)

        // Initialize all detectors
        detectors := []detector{
                pemDetector{},    // 1) PEM blocks (handles certificates, PKCS7, PKCS12 in PEM)
                jksDetector{},    // 2) JKS / JCEKS (Java keystores)
                pkcs12Detector{}, // 3) PKCS#12 (PFX)
                derDetector{},    // 4) Raw DER (single/concatenated certs, or DER-encoded PKCS#7)
                zipDetector{},    // 5) ZIP/JAR/APK META-INF
        }

        // Run all detectors
        for _, d := range detectors </span><span class="cov8" title="1">{
                hits := d.detect(ctx, b)
                add(hits, &amp;out)
        }</span>

        <span class="cov8" title="1">return out</span>
}


</pre>
		
		<pre class="file" id="file7" style="display: none">package x509

import (
        "archive/zip"
        "bytes"
        "context"
        "io"
        "log/slog"
        "strings"
)

// zipDetector handles ZIP/JAR/APK META-INF certificate detection
type zipDetector struct{}

// detect finds certificates in ZIP files (typically in META-INF for signed Java/Android artifacts)
func (d zipDetector) detect(ctx context.Context, b []byte) []certHit <span class="cov8" title="1">{
        slog.DebugContext(ctx, "Detecting ZIP/JAR/APK META-INF")
        
        var out []certHit
        
        // Check if it's a ZIP file
        if bytes.HasPrefix(b, []byte("PK\x03\x04")) </span><span class="cov8" title="1">{
                for _, h := range scanZIPForCerts(ctx, b) </span><span class="cov8" title="1">{
                        out = append(out, certHit{
                                Cert:   h.Cert,
                                Source: "ZIP/" + h.Source,
                        })
                }</span>
        }
        
        <span class="cov8" title="1">return out</span>
}

func scanZIPForCerts(ctx context.Context, b []byte) []certHit <span class="cov8" title="1">{
        var out []certHit
        zr, err := zip.NewReader(bytes.NewReader(b), int64(len(b)))
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for _, f := range zr.File </span><span class="cov8" title="1">{
                name := strings.ToUpper(f.Name)
                if !strings.HasPrefix(name, "META-INF/") </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Typical: CERT.RSA, *.RSA, *.DSA, *.EC, *.PK7
                //nolint:staticcheck // seeker is going to recognize even obsoleted crypto
                <span class="cov8" title="1">if !(strings.HasSuffix(name, ".RSA") || strings.HasSuffix(name, ".DSA") ||
                        strings.HasSuffix(name, ".EC") || strings.HasSuffix(name, ".PK7") ||
                        name == "META-INF/CERT.RSA") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">rc, err := f.Open()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">data, _ := io.ReadAll(rc)
                _ = rc.Close()

                // Recursively analyze entry contents (they're usually PKCS#7)
                sub := findAllCerts(ctx, data)
                for _, h := range sub </span><span class="cov8" title="1">{
                        out = append(out, certHit{Cert: h.Cert, Source: h.Source})
                }</span>
        }
        <span class="cov8" title="1">return out</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
